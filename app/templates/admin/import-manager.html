{% extends "base.html" %}

{% block title %}Import & Playlist Manager - IPTV PVR{% endblock %}

{% block extra_css %}
<style>
:root {
    --import-card-bg: rgba(255, 255, 255, 0.95);
    --import-card-border: #e0e0e0;
    --import-success: #28a745;
    --import-warning: #ffc107;
    --import-danger: #dc3545;
    --import-info: #17a2b8;
}

.dark-mode {
    --import-card-bg: rgba(45, 45, 45, 0.95);
    --import-card-border: #555;
}

.import-manager-container {
    display: grid;
    grid-template-columns: 1fr 400px;
    gap: 20px;
    margin-top: 20px;
}

.main-panel {
    display: flex;
    flex-direction: column;
}

.import-tabs {
    display: flex;
    background: var(--import-card-bg);
    border-radius: 12px 12px 0 0;
    border: 1px solid var(--import-card-border);
    border-bottom: none;
    overflow: hidden;
}

.import-tab {
    flex: 1;
    padding: 16px 20px;
    border: none;
    background: transparent;
    color: var(--text-body);
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
}

.import-tab.active {
    background: var(--bg-primary);
    color: var(--color-primary);
}

.import-tab::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 3px;
    background: var(--color-primary);
    transform: scaleX(0);
    transition: transform 0.3s ease;
}

.import-tab.active::after {
    transform: scaleX(1);
}

.tab-content {
    background: var(--import-card-bg);
    border: 1px solid var(--import-card-border);
    border-radius: 0 0 12px 12px;
    min-height: 600px;
    display: flex;
    flex-direction: column;
}

.tab-panel {
    display: none;
    flex: 1;
    padding: 24px;
}

.tab-panel.active {
    display: flex;
    flex-direction: column;
}

/* M3U Import */
.import-form {
    display: flex;
    flex-direction: column;
    gap: 20px;
}

.form-group {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.url-input-group {
    display: flex;
    gap: 12px;
    align-items: end;
}

.url-input {
    flex: 1;
    padding: 12px 16px;
    border: 2px solid var(--import-card-border);
    border-radius: 8px;
    background: var(--bg-primary);
    transition: border-color 0.3s ease;
}

.url-input:focus {
    outline: none;
    border-color: var(--color-primary);
}

.import-options {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 16px;
    margin-top: 20px;
}

.option-card {
    padding: 16px;
    background: var(--bg-secondary);
    border-radius: 8px;
    border: 1px solid var(--import-card-border);
}

.option-card h6 {
    margin-bottom: 12px;
    color: var(--text-heading);
}

.checkbox-group {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.checkbox-item {
    display: flex;
    align-items: center;
    gap: 8px;
}

/* Live Log */
.live-log-container {
    margin-top: 20px;
    border: 1px solid var(--import-card-border);
    border-radius: 8px;
    overflow: hidden;
    position: relative;
    z-index: 1000;
}

/* Import Progress Overlay */
.import-progress-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.7);
    z-index: 10000;
    display: none;
    align-items: center;
    justify-content: center;
}

.import-progress-modal {
    background: var(--import-card-bg);
    border-radius: 12px;
    padding: 30px;
    max-width: 600px;
    width: 90%;
    max-height: 80vh;
    overflow: hidden;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    position: relative;
    z-index: 10001;
}

.progress-header {
    display: flex;
    justify-content: between;
    align-items: center;
    margin-bottom: 20px;
    padding-bottom: 15px;
    border-bottom: 1px solid var(--import-card-border);
}

.progress-header h4 {
    margin: 0;
    color: var(--text-heading);
    display: flex;
    align-items: center;
    gap: 10px;
}

.cancel-import-btn {
    background: var(--import-danger);
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 0.9rem;
    transition: all 0.3s ease;
}

.cancel-import-btn:hover {
    background: #c82333;
    transform: translateY(-1px);
}

.progress-body {
    max-height: 400px;
    overflow-y: auto;
}

.live-log {
    height: 300px;
    overflow-y: auto;
    background: #1e1e1e;
    color: #f8f8f2;
    font-family: 'Courier New', monospace;
    font-size: 0.875rem;
    padding: 16px;
    white-space: pre-wrap;
}

.log-entry {
    display: flex;
    margin-bottom: 4px;
}

.log-timestamp {
    color: #6c757d;
    margin-right: 8px;
    min-width: 80px;
}

.log-level {
    margin-right: 8px;
    min-width: 60px;
    font-weight: bold;
}

.log-level.info { color: #17a2b8; }
.log-level.success { color: #28a745; }
.log-level.warning { color: #ffc107; }
.log-level.error { color: #dc3545; }

.log-message {
    flex: 1;
}

.import-summary {
    padding: 16px;
    background: var(--bg-secondary);
    border-top: 1px solid var(--import-card-border);
}

/* EPG Mapping */
.epg-mapping-container {
    margin-top: 20px;
    border: 1px solid var(--import-card-border);
    border-radius: 8px;
    padding: 16px;
}

.mapping-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    max-height: 400px;
    overflow-y: auto;
}

.channel-mapping {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px;
    background: var(--bg-secondary);
    border-radius: 6px;
    border: 1px solid var(--import-card-border);
}

.channel-info {
    flex: 1;
}

.channel-name {
    font-weight: 600;
    margin-bottom: 4px;
}

.channel-meta {
    font-size: 0.75rem;
    color: var(--text-muted);
}

.epg-select {
    min-width: 200px;
    padding: 6px 8px;
    border: 1px solid var(--import-card-border);
    border-radius: 4px;
    background: var(--bg-primary);
}

.mapping-status {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.75rem;
}

.mapping-status.auto { background: var(--import-info); color: white; }
.mapping-status.manual { background: var(--import-warning); color: white; }
.mapping-status.none { background: var(--import-card-border); }

@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.spinning {
    animation: spin 1s linear infinite;
}

/* Fix justify-content typo */
.progress-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    padding-bottom: 15px;
    border-bottom: 1px solid var(--import-card-border);
}

/* Playlist Management */
.playlist-list {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.playlist-item {
    display: flex;
    align-items: center;
    justify-content: between;
    padding: 16px;
    background: var(--bg-secondary);
    border: 1px solid var(--import-card-border);
    border-radius: 8px;
    transition: all 0.3s ease;
}

.playlist-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.playlist-info {
    flex: 1;
}

.playlist-name {
    font-weight: 600;
    margin-bottom: 4px;
    color: var(--text-heading);
}

.playlist-meta {
    font-size: 0.875rem;
    color: var(--text-muted);
    display: flex;
    align-items: center;
    gap: 16px;
}

.playlist-actions {
    display: flex;
    gap: 8px;
}

.action-btn {
    width: 36px;
    height: 36px;
    border: 1px solid var(--import-card-border);
    border-radius: 6px;
    background: var(--bg-primary);
    color: var(--text-body);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
}

.action-btn:hover {
    background: var(--color-primary);
    border-color: var(--color-primary);
    color: white;
}

.action-btn.danger:hover {
    background: var(--import-danger);
    border-color: var(--import-danger);
}

/* Right Sidebar */
.sidebar-panel {
    display: flex;
    flex-direction: column;
    gap: 20px;
}

.sidebar-card {
    background: var(--import-card-bg);
    border: 1px solid var(--import-card-border);
    border-radius: 12px;
    padding: 20px;
}

.sidebar-card h6 {
    margin-bottom: 16px;
    color: var(--text-heading);
    display: flex;
    align-items: center;
    gap: 8px;
}

.stats-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
}

.stat-item {
    text-align: center;
    padding: 12px;
    background: var(--bg-secondary);
    border-radius: 6px;
}

.stat-number {
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--color-primary);
}

.stat-label {
    font-size: 0.875rem;
    color: var(--text-muted);
}

.recent-imports {
    max-height: 300px;
    overflow-y: auto;
}

.import-log-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 8px 0;
    border-bottom: 1px solid var(--import-card-border);
}

.import-log-item:last-child {
    border-bottom: none;
}

.log-status {
    width: 8px;
    height: 8px;
    border-radius: 50%;
}

.log-status.success { background: var(--import-success); }
.log-status.error { background: var(--import-danger); }
.log-status.warning { background: var(--import-warning); }

.log-details {
    flex: 1;
    font-size: 0.875rem;
}

.log-time {
    font-size: 0.75rem;
    color: var(--text-muted);
}

/* Export */
.export-options {
    display: flex;
    flex-direction: column;
    gap: 16px;
}

.export-format {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 16px;
    background: var(--bg-secondary);
    border: 2px solid var(--import-card-border);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.export-format:hover,
.export-format.selected {
    border-color: var(--color-primary);
    background: var(--channel-selected-bg);
}

.format-icon {
    width: 48px;
    height: 48px;
    background: var(--color-primary);
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 1.25rem;
}

.format-info h6 {
    margin-bottom: 4px;
    color: var(--text-heading);
}

.format-description {
    font-size: 0.875rem;
    color: var(--text-muted);
}

/* Responsive */
@media (max-width: 1024px) {
    .import-manager-container {
        grid-template-columns: 1fr;
    }
    
    .import-options {
        grid-template-columns: 1fr;
    }
}
</style>
{% endblock %}

{% block content %}
<div class="container-fluid">
    <!-- Header -->
    <div class="d-flex justify-content-between align-items-center mb-4">
        <div>
            <h1 class="h3 mb-0">Import & Playlist Manager</h1>
            <p class="text-muted mb-0">Import playlists, manage channels, and configure EPG sources</p>
        </div>
        <div class="d-flex gap-2">
            <button class="btn btn-outline-primary" id="scheduleImportBtn">
                <i class="bi bi-clock"></i> Schedule Import
            </button>
            <button class="btn btn-outline-success" id="backupBtn">
                <i class="bi bi-shield-check"></i> Backup
            </button>
        </div>
    </div>

    <div class="import-manager-container">
        <!-- Main Panel -->
        <div class="main-panel">
            <!-- Tabs -->
            <div class="import-tabs">
                <button class="import-tab active" data-tab="m3u">
                    <i class="bi bi-file-earmark-music"></i> M3U Import
                </button>
                <button class="import-tab" data-tab="playlists">
                    <i class="bi bi-collection-play"></i> Playlists
                </button>
                <button class="import-tab" data-tab="epg">
                    <i class="bi bi-broadcast"></i> EPG Sources
                </button>
                <button class="import-tab" data-tab="export">
                    <i class="bi bi-download"></i> Export
                </button>
            </div>

            <!-- Tab Content -->
            <div class="tab-content">
                <!-- M3U Import Tab -->
                <div class="tab-panel active" id="m3u-panel">
                    <div class="import-form">
                        <div class="form-group">
                            <label class="form-label fw-semibold">Source Name</label>
                            <input type="text" class="url-input" id="sourceName" placeholder="My IPTV Provider" style="margin-bottom: 12px;">
                        </div>

                        <div class="form-group">
                            <label class="form-label fw-semibold">M3U Playlist URL or File</label>
                            <div class="url-input-group">
                                <input type="text" class="url-input" id="m3uUrl" placeholder="https://example.com/playlist.m3u or upload file">
                                <button class="btn btn-outline-secondary" id="uploadFileBtn">
                                    <i class="bi bi-upload"></i> Upload
                                </button>
                                <button class="btn btn-outline-warning" id="validateBtn">
                                    <i class="bi bi-check2-square"></i> Validate
                                </button>
                            </div>
                            <input type="file" id="fileInput" accept=".m3u,.m3u8" style="display: none;">
                        </div>

                        <div class="form-group">
                            <label class="form-label fw-semibold">
                                <i class="bi bi-broadcast"></i> EPG Source URL (Optional)
                            </label>
                            <div class="url-input-group">
                                <input type="text" class="url-input" id="epgUrl" placeholder="https://example.com/epg.xml (XMLTV format)">
                                <button class="btn btn-outline-info" id="testEpgBtn">
                                    <i class="bi bi-check-circle"></i> Test
                                </button>
                            </div>
                            <small class="text-muted">
                                <i class="bi bi-info-circle"></i> 
                                Provide an XMLTV EPG source to automatically link channel guide data
                            </small>
                        </div>

                        <!-- Source Actions -->
                        <div class="d-flex gap-2 mb-3">
                            <button class="btn btn-success" id="saveSourceBtn">
                                <i class="bi bi-bookmark-plus"></i> Save as Source
                            </button>
                            <button class="btn btn-primary" id="importBtn">
                                <i class="bi bi-download"></i> Import Now
                            </button>
                        </div>

                        <div class="import-options">
                            <div class="option-card">
                                <h6><i class="bi bi-sliders"></i> Import Options</h6>
                                <div class="checkbox-group">
                                    <label class="checkbox-item">
                                        <input type="checkbox" id="updateExisting" checked>
                                        <span>Update existing channels</span>
                                    </label>
                                    <label class="checkbox-item">
                                        <input type="checkbox" id="preserveGroups" checked>
                                        <span>Preserve existing groups</span>
                                    </label>
                                    <div class="checkbox-group">
                                        <label class="checkbox-item">
                                            <input type="radio" name="epgMapping" id="epgMappingAuto" value="auto" checked>
                                            <span>Auto-map EPG channels</span>
                                        </label>
                                        <label class="checkbox-item">
                                            <input type="radio" name="epgMapping" id="epgMappingManual" value="manual">
                                            <span>Manual EPG mapping</span>
                                        </label>
                                        <label class="checkbox-item">
                                            <input type="radio" name="epgMapping" id="epgMappingNone" value="none">
                                            <span>Skip EPG mapping</span>
                                        </label>
                                    </div>
                                    <label class="checkbox-item">
                                        <input type="checkbox" id="validateUrls">
                                        <span>Validate stream URLs</span>
                                    </label>
                                </div>
                            </div>

                            <div class="option-card">
                                <h6><i class="bi bi-funnel"></i> Filters</h6>
                                <div class="checkbox-group">
                                    <label class="checkbox-item">
                                        <input type="checkbox" id="skipDuplicates" checked>
                                        <span>Skip duplicate channels</span>
                                    </label>
                                    <label class="checkbox-item">
                                        <input type="checkbox" id="filterAdult">
                                        <span>Filter adult content</span>
                                    </label>
                                    <label class="checkbox-item">
                                        <input type="checkbox" id="onlyHD">
                                        <span>HD channels only</span>
                                    </label>
                                    <label class="checkbox-item">
                                        <input type="checkbox" id="testStreams">
                                        <span>Test streams before import</span>
                                    </label>
                                </div>
                            </div>
                        </div>

                        <!-- Live Import Log -->
                        <div class="live-log-container" id="liveLogContainer" style="display: none;">
                            <div class="d-flex justify-content-between align-items-center mb-3">
                                <h6 class="mb-0">
                                    <i class="bi bi-terminal"></i> Live Import Log
                                </h6>
                                <div class="d-flex gap-2">
                                    <button class="btn btn-sm btn-outline-secondary" id="clearLogBtn">
                                        <i class="bi bi-trash"></i> Clear
                                    </button>
                                    <button class="btn btn-sm btn-outline-danger" id="cancelImportBtn">
                                        <i class="bi bi-x-circle"></i> Cancel
                                    </button>
                                </div>
                            </div>
                            <div class="live-log" id="liveLog">
                                <!-- Log entries will be added here -->
                            </div>
                            <div class="import-summary" id="importSummary" style="display: none;">
                                <!-- Summary will be shown here -->
                            </div>
                        </div>

                        <!-- EPG Mapping Interface -->
                        <div class="epg-mapping-container" id="epgMappingContainer" style="display: none;">
                            <div class="d-flex justify-content-between align-items-center mb-3">
                                <h6 class="mb-0">
                                    <i class="bi bi-broadcast"></i> EPG Channel Mapping
                                </h6>
                                <div class="d-flex gap-2">
                                    <button class="btn btn-sm btn-outline-info" id="autoMapBtn">
                                        <i class="bi bi-magic"></i> Auto Map
                                    </button>
                                    <button class="btn btn-sm btn-success" id="confirmMappingBtn">
                                        <i class="bi bi-check-lg"></i> Confirm Mapping
                                    </button>
                                </div>
                            </div>
                            <div class="mapping-grid" id="mappingGrid">
                                <!-- Mapping interface will be populated here -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Playlists Tab -->
                <div class="tab-panel" id="playlists-panel">
                    <!-- Sub-tabs for better organization -->
                    <div class="d-flex mb-3">
                        <button class="btn btn-sm btn-outline-primary active me-2" id="sourcesSubTab" onclick="importManager.switchPlaylistSubTab('sources')">
                            <i class="bi bi-bookmark"></i> Sources
                        </button>
                        <button class="btn btn-sm btn-outline-primary" id="importedSubTab" onclick="importManager.switchPlaylistSubTab('imported')">
                            <i class="bi bi-collection-play"></i> Imported Playlists
                        </button>
                    </div>

                    <!-- Sources Sub-panel -->
                    <div id="sources-subpanel">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h5>Saved Sources</h5>
                            <button class="btn btn-primary" id="addSourceBtn">
                                <i class="bi bi-plus"></i> Add Source
                            </button>
                        </div>
                        <div class="playlist-list" id="sourcesList">
                            <!-- Sources will be loaded here -->
                        </div>
                    </div>

                    <!-- Imported Playlists Sub-panel -->
                    <div id="imported-subpanel" style="display: none;">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h5>Imported Playlists</h5>
                        </div>
                        <div class="playlist-list" id="playlistList">
                            <!-- Playlists will be loaded here -->
                        </div>
                    </div>
                </div>

                <!-- EPG Sources Tab -->
                <div class="tab-panel" id="epg-panel">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h5>EPG Sources</h5>
                        <button class="btn btn-primary" id="addEpgSourceBtn">
                            <i class="bi bi-plus"></i> Add EPG Source
                        </button>
                    </div>
                    <div id="epgSourcesList">
                        <!-- EPG sources will be loaded here -->
                    </div>
                </div>

                <!-- Export Tab -->
                <div class="tab-panel" id="export-panel">
                    <h5 class="mb-3">Export Channels & Playlists</h5>
                    <div class="export-options">
                        <div class="export-format selected" data-format="m3u">
                            <div class="format-icon">
                                <i class="bi bi-file-earmark-music"></i>
                            </div>
                            <div class="format-info">
                                <h6>M3U Playlist</h6>
                                <div class="format-description">Standard M3U format with extended info</div>
                            </div>
                        </div>
                        <div class="export-format" data-format="json">
                            <div class="format-icon">
                                <i class="bi bi-filetype-json"></i>
                            </div>
                            <div class="format-info">
                                <h6>JSON Export</h6>
                                <div class="format-description">Complete channel and group data</div>
                            </div>
                        </div>
                        <div class="export-format" data-format="xmltv">
                            <div class="format-icon">
                                <i class="bi bi-filetype-xml"></i>
                            </div>
                            <div class="format-info">
                                <h6>XMLTV EPG</h6>
                                <div class="format-description">Electronic Program Guide data</div>
                            </div>
                        </div>
                    </div>
                    <div class="mt-4">
                        <button class="btn btn-success btn-lg w-100" id="exportBtn">
                            <i class="bi bi-download"></i> Export Selected Format
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Sidebar -->
        <div class="sidebar-panel">
            <!-- Statistics -->
            <div class="sidebar-card">
                <h6><i class="bi bi-graph-up"></i> Import Statistics</h6>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-number" id="totalChannels">0</div>
                        <div class="stat-label">Total Channels</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-number" id="totalGroups">0</div>
                        <div class="stat-label">Groups</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-number" id="activePlaylists">0</div>
                        <div class="stat-label">Active Playlists</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-number" id="epgSources">0</div>
                        <div class="stat-label">EPG Sources</div>
                    </div>
                </div>
            </div>

            <!-- Recent Imports -->
            <div class="sidebar-card">
                <h6><i class="bi bi-clock-history"></i> Recent Activity</h6>
                <div class="recent-imports" id="recentImports">
                    <!-- Recent import logs -->
                </div>
            </div>

            <!-- Quick Actions -->
            <div class="sidebar-card">
                <h6><i class="bi bi-lightning"></i> Quick Actions</h6>
                <div class="d-flex flex-column gap-2">
                    <button class="btn btn-outline-primary btn-sm" id="refreshAllBtn">
                        <i class="bi bi-arrow-clockwise"></i> Refresh All Playlists
                    </button>
                    <button class="btn btn-outline-info btn-sm" id="validateAllBtn">
                        <i class="bi bi-check-circle"></i> Validate All Streams
                    </button>
                    <button class="btn btn-outline-warning btn-sm" id="cleanupBtn">
                        <i class="bi bi-trash3"></i> Cleanup Inactive
                    </button>
                    <button class="btn btn-outline-success btn-sm" id="backupAllBtn">
                        <i class="bi bi-shield-check"></i> Backup Configuration
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Import Progress Overlay -->
<div class="import-progress-overlay" id="importProgressOverlay">
    <div class="import-progress-modal">
        <div class="progress-header">
            <h4>
                <i class="bi bi-download spinning"></i>
                <span id="progressTitle">Importing...</span>
            </h4>
            <button class="cancel-import-btn" id="cancelImportOverlay">
                <i class="bi bi-x-circle"></i> Cancel
            </button>
        </div>
        <div class="progress-body">
            <div class="mb-3">
                <div class="progress" style="height: 8px;">
                    <div class="progress-bar progress-bar-striped progress-bar-animated" 
                         id="importProgressBar" style="width: 0%"></div>
                </div>
                <div class="d-flex justify-content-between mt-1">
                    <small class="text-muted" id="progressStatus">Starting...</small>
                    <small class="text-muted" id="progressPercent">0%</small>
                </div>
            </div>
            <div class="live-log" id="overlayLiveLog" style="height: 250px;">
                <!-- Progress messages will appear here -->
            </div>
        </div>
    </div>
</div>

<!-- Source Configuration Modal -->
<div class="modal fade" id="sourceConfigModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">
                    <i class="bi bi-gear"></i> Configure Source
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body" id="sourceConfigBody">
                <!-- Source configuration will be loaded here -->
            </div>
        </div>
    </div>
</div>

{% endblock %}

{% block extra_js %}
<script>
class ImportManager {
    constructor() {
        this.currentTab = 'm3u';
        this.playlists = [];
        this.epgSources = [];
        this.stats = {
            totalChannels: 0,
            totalGroups: 0,
            activePlaylists: 0,
            epgSources: 0
        };
        this.importSettings = this.loadSettings();
        this.isImporting = false;
        this.importAborted = false;
        this.currentChannels = [];
        this.currentEpgData = [];
        
        this.init();
    }
    
    async init() {
        await this.loadData();
        this.setupEventListeners();
        this.updateStats();
        this.loadRecentActivity();
        this.restoreSettings();
    }
    
    loadSettings() {
        const saved = localStorage.getItem('importSettings');
        return saved ? JSON.parse(saved) : {
            sourceName: '',
            m3uUrl: '',
            epgUrl: '',
            updateExisting: true,
            preserveGroups: true,
            epgMapping: 'auto',
            validateUrls: false,
            skipDuplicates: true,
            filterAdult: false,
            onlyHD: false,
            testStreams: false
        };
    }
    
    saveSettings() {
        if (document.getElementById('saveSettings').checked) {
            const settings = {
                sourceName: document.getElementById('sourceName').value,
                m3uUrl: document.getElementById('m3uUrl').value,
                epgUrl: document.getElementById('epgUrl').value,
                updateExisting: document.getElementById('updateExisting').checked,
                preserveGroups: document.getElementById('preserveGroups').checked,
                epgMapping: document.querySelector('input[name="epgMapping"]:checked').value,
                validateUrls: document.getElementById('validateUrls').checked,
                skipDuplicates: document.getElementById('skipDuplicates').checked,
                filterAdult: document.getElementById('filterAdult').checked,
                onlyHD: document.getElementById('onlyHD').checked,
                testStreams: document.getElementById('testStreams').checked
            };
            localStorage.setItem('importSettings', JSON.stringify(settings));
        }
    }
    
    restoreSettings() {
        document.getElementById('sourceName').value = this.importSettings.sourceName;
        document.getElementById('m3uUrl').value = this.importSettings.m3uUrl;
        document.getElementById('epgUrl').value = this.importSettings.epgUrl;
        document.getElementById('updateExisting').checked = this.importSettings.updateExisting;
        document.getElementById('preserveGroups').checked = this.importSettings.preserveGroups;
        document.querySelector(`input[name="epgMapping"][value="${this.importSettings.epgMapping}"]`).checked = true;
        document.getElementById('validateUrls').checked = this.importSettings.validateUrls;
        document.getElementById('skipDuplicates').checked = this.importSettings.skipDuplicates;
        document.getElementById('filterAdult').checked = this.importSettings.filterAdult;
        document.getElementById('onlyHD').checked = this.importSettings.onlyHD;
        document.getElementById('testStreams').checked = this.importSettings.testStreams;
    }
    
    setupEventListeners() {
        // Tab switching
        document.querySelectorAll('.import-tab').forEach(tab => {
            tab.addEventListener('click', (e) => {
                const tabName = e.target.dataset.tab;
                this.switchTab(tabName);
            });
        });
        
        // File upload
        document.getElementById('uploadFileBtn').addEventListener('click', () => {
            document.getElementById('fileInput').click();
        });
        
        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                this.handleFileUpload(file);
            }
        });
        
        // Import
        document.getElementById('importBtn').addEventListener('click', () => {
            this.startImport();
        });
        
        // Test EPG
        document.getElementById('testEpgBtn').addEventListener('click', () => {
            this.testEpgSource();
        });
        
        // Validate M3U
        document.getElementById('validateBtn').addEventListener('click', () => {
            this.validateM3uSource();
        });
        
        // Save source
        document.getElementById('saveSourceBtn').addEventListener('click', () => {
            this.saveSource();
        });
        
        // Live log controls
        document.getElementById('clearLogBtn').addEventListener('click', () => {
            this.clearLog();
        });
        
        document.getElementById('cancelImportBtn').addEventListener('click', () => {
            this.cancelImport();
        });
        
        // EPG mapping
        document.getElementById('autoMapBtn').addEventListener('click', () => {
            this.autoMapChannels();
        });
        
        document.getElementById('confirmMappingBtn').addEventListener('click', () => {
            this.confirmMapping();
        });
        
        // Progress overlay controls
        document.getElementById('cancelImportOverlay').addEventListener('click', () => {
            this.cancelImport();
            this.hideProgressOverlay();
        });
        
        // Export formats
        document.querySelectorAll('.export-format').forEach(format => {
            format.addEventListener('click', (e) => {
                document.querySelectorAll('.export-format').forEach(f => f.classList.remove('selected'));
                e.currentTarget.classList.add('selected');
            });
        });
        
        // Export
        document.getElementById('exportBtn').addEventListener('click', () => {
            this.exportData();
        });
        
        // Quick actions
        document.getElementById('refreshAllBtn').addEventListener('click', () => this.refreshAllPlaylists());
        document.getElementById('validateAllBtn').addEventListener('click', () => this.validateAllStreams());
        document.getElementById('cleanupBtn').addEventListener('click', () => this.cleanupInactive());
        document.getElementById('backupAllBtn').addEventListener('click', () => this.backupConfiguration());
    }
    
    switchTab(tabName) {
        // Update tab buttons
        document.querySelectorAll('.import-tab').forEach(tab => {
            tab.classList.toggle('active', tab.dataset.tab === tabName);
        });
        
        // Update panels
        document.querySelectorAll('.tab-panel').forEach(panel => {
            panel.classList.toggle('active', panel.id === `${tabName}-panel`);
        });
        
        this.currentTab = tabName;
        
        // Load tab-specific data
        switch(tabName) {
            case 'playlists':
                this.loadSources();
                this.loadPlaylists();
                break;
            case 'epg':
                this.loadEpgSources();
                break;
        }
    }
    
    async loadData() {
        try {
            const [channelsResponse, groupsResponse, playlistsResponse] = await Promise.all([
                fetch('/api/channels/'),
                fetch('/api/channels/groups'),
                fetch('/api/channels/playlists')
            ]);
            
            const channels = await channelsResponse.json();
            const groups = await groupsResponse.json();
            this.playlists = await playlistsResponse.json();
            
            this.stats = {
                totalChannels: channels.length,
                totalGroups: groups.length,
                activePlaylists: this.playlists.length,
                epgSources: 0 // Will be loaded separately
            };
        } catch (error) {
            console.error('Error loading data:', error);
        }
    }
    
    updateStats() {
        document.getElementById('totalChannels').textContent = this.stats.totalChannels;
        document.getElementById('totalGroups').textContent = this.stats.totalGroups;
        document.getElementById('activePlaylists').textContent = this.stats.activePlaylists;
        document.getElementById('epgSources').textContent = this.stats.epgSources;
    }
    
    handleFileUpload(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            const content = e.target.result;
            document.getElementById('m3uUrl').value = `file:${file.name}`;
            // Store file content for processing
            this.fileContent = content;
        };
        reader.readAsText(file);
    }
    
    async startImport() {
        const url = document.getElementById('m3uUrl').value.trim();
        const sourceName = document.getElementById('sourceName').value.trim();
        
        if (!url && !this.fileContent) {
            this.showNotification('Please provide a URL or upload a file', 'error');
            return;
        }
        
        if (!sourceName) {
            this.showNotification('Please provide a source name', 'error');
            return;
        }
        
        // Show confirmation for large playlists
        if (await this.shouldConfirmImport(url)) {
            if (!confirm('This appears to be a large playlist. Import may take several minutes. Continue?')) {
                return;
            }
        }
        
        // Show progress overlay
        this.showProgressOverlay();
        this.updateProgress(0, 'Starting import...', 'Initializing');
        
        try {
            // Start non-blocking import via API
            await this.startNonBlockingImport(sourceName, url);
            
        } catch (error) {
            this.hideProgressOverlay();
            this.showNotification('Failed to start import: ' + error.message, 'error');
        }
    }
    
    async startNonBlockingImport(sourceName, m3uUrl) {
        const epgUrl = document.getElementById('epgUrl').value.trim();
        
        this.addProgressLog('info', 'Starting import process...');
        this.addProgressLog('info', `Source: ${sourceName}`);
        this.addProgressLog('info', `M3U URL: ${m3uUrl}`);
        
        try {
            this.updateProgress(10, 'Creating playlist...', 'Setting up import');
            
            // Use existing playlist import API
            const response = await fetch('/api/channels/playlists/import', {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${localStorage.getItem('token')}`
                },
                body: JSON.stringify({
                    name: sourceName,
                    url: m3uUrl,
                    epg_url: epgUrl
                })
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.detail || `Import failed: ${response.statusText}`);
            }
            
            const result = await response.json();
            this.currentImportId = result.import_id;
            
            this.addProgressLog('success', `Import started with ID: ${result.import_id}`);
            this.addProgressLog('info', `Playlist ID: ${result.playlist_id}`);
            
            // Start WebSocket connection for progress updates
            this.connectToImportProgress(result.import_id);
            
            // Import EPG data if provided
            if (epgUrl) {
                this.addProgressLog('info', 'Starting EPG import...');
                try {
                    const epgResponse = await fetch('/api/epg/import', {
                        method: 'POST',
                        headers: { 
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${localStorage.getItem('token')}`
                        },
                        body: JSON.stringify({
                            url: epgUrl,
                            update_interval: 21600
                        })
                    });
                    
                    if (epgResponse.ok) {
                        this.addProgressLog('success', 'EPG import started');
                    } else {
                        this.addProgressLog('warning', 'EPG import failed but playlist import continues');
                    }
                } catch (epgError) {
                    this.addProgressLog('warning', `EPG import failed: ${epgError.message}`);
                }
            }
            
        } catch (error) {
            this.addProgressLog('error', `Import failed: ${error.message}`);
            setTimeout(() => this.hideProgressOverlay(), 3000);
            throw error;
        }
    }
    
    // Progress overlay methods
    showProgressOverlay() {
        document.getElementById('importProgressOverlay').style.display = 'flex';
        document.body.style.overflow = 'hidden';
    }
    
    hideProgressOverlay() {
        document.getElementById('importProgressOverlay').style.display = 'none';
        document.body.style.overflow = '';
        if (this.importWebSocket) {
            this.importWebSocket.close();
            this.importWebSocket = null;
        }
    }
    
    updateProgress(percent, status, title = 'Importing...') {
        document.getElementById('importProgressBar').style.width = `${percent}%`;
        document.getElementById('progressPercent').textContent = `${Math.round(percent)}%`;
        document.getElementById('progressStatus').textContent = status;
        document.getElementById('progressTitle').textContent = title;
    }
    
    addProgressLog(level, message) {
        const timestamp = new Date().toLocaleTimeString();
        const logEntry = document.createElement('div');
        logEntry.className = 'log-entry';
        logEntry.innerHTML = `
            <span class="log-timestamp">${timestamp}</span>
            <span class="log-level ${level}">[${level.toUpperCase()}]</span>
            <span class="log-message">${message}</span>
        `;
        
        const liveLog = document.getElementById('overlayLiveLog');
        liveLog.appendChild(logEntry);
        liveLog.scrollTop = liveLog.scrollHeight;
    }
    
    connectToImportProgress(importId) {
        try {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/${importId}`;
            
            this.importWebSocket = new WebSocket(wsUrl);
            
            this.importWebSocket.onopen = () => {
                this.addProgressLog('info', 'Connected to live progress updates');
            };
            
            this.importWebSocket.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    this.handleProgressUpdate(data);
                } catch (error) {
                    console.error('Failed to parse WebSocket message:', error);
                }
            };
            
            this.importWebSocket.onerror = (error) => {
                console.error('WebSocket error:', error);
                this.addProgressLog('warning', 'Live updates connection failed, using fallback');
                this.startProgressPolling(importId);
            };
            
            this.importWebSocket.onclose = () => {
                console.log('WebSocket connection closed');
            };
            
        } catch (error) {
            console.error('Failed to connect to WebSocket:', error);
            this.addProgressLog('warning', 'Using fallback progress tracking');
            this.startProgressPolling(importId);
        }
    }
    
    handleProgressUpdate(data) {
        if (data.status === 'progress') {
            this.updateProgress(data.progress || 0, data.message || 'Processing...', data.details || 'Importing');
            this.addProgressLog('info', data.message || 'Progress update');
        } else if (data.status === 'completed') {
            this.updateProgress(100, 'Import completed successfully!', 'Completed');
            this.addProgressLog('success', `Import completed: ${data.message || 'Success'}`);
            setTimeout(() => {
                this.hideProgressOverlay();
                this.showNotification('Import completed successfully!', 'success');
                this.loadData(); // Refresh data
            }, 2000);
        } else if (data.status === 'failed') {
            this.updateProgress(0, 'Import failed', 'Error');
            this.addProgressLog('error', `Import failed: ${data.message || 'Unknown error'}`);
            setTimeout(() => this.hideProgressOverlay(), 3000);
        }
    }
    
    startProgressPolling(importId) {
        // Fallback polling mechanism
        this.progressPollInterval = setInterval(async () => {
            try {
                const response = await fetch(`/api/channels/import-stats?import_id=${importId}`, {
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('token')}` }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    this.handleProgressUpdate(data);
                    
                    if (data.status === 'completed' || data.status === 'failed') {
                        clearInterval(this.progressPollInterval);
                    }
                }
            } catch (error) {
                console.error('Progress polling error:', error);
            }
        }, 2000);
    }
    
    // Live logging methods (kept for compatibility)
    showLiveLog() {
        document.getElementById('liveLogContainer').style.display = 'block';
        document.getElementById('epgMappingContainer').style.display = 'none';
    }
    
    clearLog() {
        document.getElementById('liveLog').innerHTML = '';
    }
    
    addLogEntry(level, message) {
        const timestamp = new Date().toLocaleTimeString();
        const logEntry = document.createElement('div');
        logEntry.className = 'log-entry';
        logEntry.innerHTML = `
            <span class="log-timestamp">${timestamp}</span>
            <span class="log-level ${level}">[${level.toUpperCase()}]</span>
            <span class="log-message">${message}</span>
        `;
        
        const liveLog = document.getElementById('liveLog');
        liveLog.appendChild(logEntry);
        liveLog.scrollTop = liveLog.scrollHeight;
    }
    
    async shouldConfirmImport(url) {
        // Quick check for large playlists (basic heuristic)
        try {
            const response = await fetch(url, { method: 'HEAD' });
            const contentLength = response.headers.get('content-length');
            return contentLength && parseInt(contentLength) > 1024 * 1024; // > 1MB
        } catch {
            return false;
        }
    }
    
    async downloadWithProgress(url) {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const contentLength = response.headers.get('content-length');
        if (contentLength) {
            this.addLogEntry('info', `Downloading ${Math.round(parseInt(contentLength) / 1024)} KB...`);
        }
        
        const content = await response.text();
        this.addLogEntry('success', 'Download completed');
        return content;
    }
    
    async parseM3uContent(content) {
        // Simulate M3U parsing with progress updates
        const lines = content.split('\n');
        const channels = [];
        let currentChannel = null;
        
        for (let i = 0; i < lines.length; i++) {
            if (this.importAborted) break;
            
            const line = lines[i].trim();
            if (line.startsWith('#EXTINF:')) {
                // Parse channel info
                currentChannel = { name: 'Unknown', group: 'General' };
                const match = line.match(/,(.+)$/);
                if (match) currentChannel.name = match[1];
            } else if (line && !line.startsWith('#')) {
                // Stream URL
                if (currentChannel) {
                    currentChannel.url = line;
                    channels.push(currentChannel);
                    currentChannel = null;
                }
            }
            
            // Progress update every 1000 lines
            if (i % 1000 === 0 && i > 0) {
                this.addLogEntry('info', `Processed ${i}/${lines.length} lines...`);
                await new Promise(resolve => setTimeout(resolve, 10));
            }
        }
        
        return channels;
    }
    
    async downloadEpgData(epgUrl) {
        try {
            // Simple download to test accessibility
            const response = await fetch(epgUrl, { method: 'HEAD' });
            
            if (response.ok) {
                // Return mock EPG data for demonstration
                // In a real implementation, this would parse the XMLTV content
                return [
                    { id: 'ch1', displayName: 'Channel 1' },
                    { id: 'ch2', displayName: 'Channel 2' },
                    { id: 'ch3', displayName: 'News Channel' }
                ];
            } else {
                throw new Error(`EPG source not accessible: ${response.status}`);
            }
        } catch (error) {
            throw new Error(`EPG download failed: ${error.message}`);
        }
    }
    
    cancelImport() {
        this.importAborted = true;
        this.isImporting = false;
        this.addLogEntry('warning', 'Import cancelled by user');
    }
    
    // EPG Mapping methods
    showEpgMapping() {
        document.getElementById('liveLogContainer').style.display = 'none';
        document.getElementById('epgMappingContainer').style.display = 'block';
        this.renderMappingGrid();
    }
    
    renderMappingGrid() {
        const grid = document.getElementById('mappingGrid');
        grid.innerHTML = '';
        
        this.currentChannels.forEach((channel, index) => {
            const mappingItem = document.createElement('div');
            mappingItem.className = 'channel-mapping';
            mappingItem.innerHTML = `
                <div class="channel-info">
                    <div class="channel-name">${channel.name}</div>
                    <div class="channel-meta">Group: ${channel.group}</div>
                </div>
                <select class="epg-select" data-channel-index="${index}">
                    <option value="">No EPG mapping</option>
                    ${this.currentEpgData.map(epg => 
                        `<option value="${epg.id}">${epg.displayName}</option>`
                    ).join('')}
                </select>
                <div class="mapping-status none" data-index="${index}">
                    <i class="bi bi-question"></i>
                </div>
            `;
            grid.appendChild(mappingItem);
        });
    }
    
    autoMapChannels() {
        this.addLogEntry('info', 'Starting automatic EPG mapping...');
        let mapped = 0;
        
        this.currentChannels.forEach((channel, index) => {
            const select = document.querySelector(`select[data-channel-index="${index}"]`);
            const status = document.querySelector(`.mapping-status[data-index="${index}"]`);
            
            // Simple name matching
            const epgMatch = this.currentEpgData.find(epg => 
                epg.displayName.toLowerCase().includes(channel.name.toLowerCase()) ||
                channel.name.toLowerCase().includes(epg.displayName.toLowerCase())
            );
            
            if (epgMatch) {
                select.value = epgMatch.id;
                status.className = 'mapping-status auto';
                status.innerHTML = '<i class="bi bi-check"></i>';
                mapped++;
            }
        });
        
        this.addLogEntry('success', `Auto-mapped ${mapped} channels`);
    }
    
    async confirmMapping() {
        const mappings = [];
        document.querySelectorAll('.epg-select').forEach(select => {
            const channelIndex = parseInt(select.dataset.channelIndex);
            if (select.value) {
                mappings.push({
                    channel: this.currentChannels[channelIndex],
                    epgId: select.value
                });
            }
        });
        
        this.addLogEntry('info', `Confirmed ${mappings.length} EPG mappings`);
        this.currentChannels.forEach((channel, index) => {
            const mapping = mappings.find(m => m.channel === channel);
            if (mapping) {
                channel.epgId = mapping.epgId;
            }
        });
        
        // Continue with import
        document.getElementById('epgMappingContainer').style.display = 'none';
        this.showLiveLog();
        await this.importToDatabase();
    }
    
    async importToDatabase() {
        this.addLogEntry('info', 'Importing channels to database...');
        
        try {
            const sourceName = document.getElementById('sourceName').value.trim();
            const m3uUrl = document.getElementById('m3uUrl').value.trim();
            const epgUrl = document.getElementById('epgUrl').value.trim();
            
            // Use existing playlist import API
            const response = await fetch('/api/channels/playlists/import', {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${localStorage.getItem('token')}`
                },
                body: JSON.stringify({
                    name: sourceName,
                    url: m3uUrl,
                    epg_url: epgUrl
                })
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.detail || `Import failed: ${response.statusText}`);
            }
            
            const result = await response.json();
            this.addLogEntry('success', `Import started with ID: ${result.import_id}`);
            this.addLogEntry('success', `Playlist ID: ${result.playlist_id}`);
            
            // Import EPG data if provided
            if (epgUrl) {
                try {
                    this.addLogEntry('info', 'Importing EPG data...');
                    const epgResponse = await fetch('/api/epg/import', {
                        method: 'POST',
                        headers: { 
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${localStorage.getItem('token')}`
                        },
                        body: JSON.stringify({
                            url: epgUrl,
                            update_interval: 21600
                        })
                    });
                    
                    if (epgResponse.ok) {
                        this.addLogEntry('success', 'EPG import started successfully');
                    } else {
                        this.addLogEntry('warning', 'EPG import failed but playlist import succeeded');
                    }
                } catch (epgError) {
                    this.addLogEntry('warning', `EPG import failed: ${epgError.message}`);
                }
            }
            
            this.showNotification('Import started successfully! Check progress in channel manager.', 'success');
            await this.loadData();
            this.updateStats();
            
        } catch (error) {
            this.addLogEntry('error', `Import failed: ${error.message}`);
            throw error;
        }
    }
    
    // Source management methods
    async saveSource() {
        const sourceName = document.getElementById('sourceName').value.trim();
        const m3uUrl = document.getElementById('m3uUrl').value.trim();
        const epgUrl = document.getElementById('epgUrl').value.trim();
        
        if (!sourceName || !m3uUrl) {
            this.showNotification('Please provide source name and M3U URL', 'error');
            return;
        }
        
        try {
            // Create playlist first
            const playlistResponse = await fetch('/api/channels/playlists/import', {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${localStorage.getItem('token')}`
                },
                body: JSON.stringify({
                    name: sourceName,
                    url: m3uUrl,
                    epg_url: epgUrl
                })
            });
            
            if (playlistResponse.ok) {
                const result = await playlistResponse.json();
                
                // Save EPG source if provided
                if (epgUrl) {
                    try {
                        await fetch('/api/epg/sources', {
                            method: 'POST',
                            headers: { 
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${localStorage.getItem('token')}`
                            },
                            body: JSON.stringify({
                                name: `${sourceName} EPG`,
                                url: epgUrl,
                                playlist_id: result.playlist_id
                            })
                        });
                    } catch (epgError) {
                        console.warn('Failed to save EPG source:', epgError);
                    }
                }
                
                this.showNotification(`Source "${sourceName}" saved successfully!`, 'success');
                await this.loadData();
            } else {
                const error = await playlistResponse.json();
                throw new Error(error.detail || 'Failed to save source');
            }
        } catch (error) {
            this.showNotification('Failed to save source: ' + error.message, 'error');
        }
    }
    
    async validateM3uSource() {
        const url = document.getElementById('m3uUrl').value.trim();
        if (!url) {
            this.showNotification('Please enter an M3U URL to validate', 'warning');
            return;
        }
        
        const validateBtn = document.getElementById('validateBtn');
        const originalContent = validateBtn.innerHTML;
        validateBtn.innerHTML = '<i class="bi bi-arrow-clockwise spinning"></i> Validating...';
        validateBtn.disabled = true;
        
        try {
            // First test accessibility
            const response = await fetch(url, { 
                method: 'HEAD',
                mode: 'cors'
            });
            
            if (response.ok) {
                const contentType = response.headers.get('content-type');
                const contentLength = response.headers.get('content-length');
                const size = contentLength ? Math.round(parseInt(contentLength) / 1024) + ' KB' : 'Unknown size';
                
                // Try to fetch a small portion to validate content
                try {
                    const partialResponse = await fetch(url, {
                        headers: { 'Range': 'bytes=0-1023' }
                    });
                    const sample = await partialResponse.text();
                    
                    if (sample.includes('#EXTM3U') || sample.includes('#EXTINF')) {
                        this.showNotification(`✅ Valid M3U playlist! Size: ${size}`, 'success');
                    } else {
                        this.showNotification(`⚠️ File accessible but doesn't appear to be M3U format. Size: ${size}`, 'warning');
                    }
                } catch (rangeError) {
                    // Fallback to content-type check
                    if (contentType && (contentType.includes('audio/x-mpegurl') || contentType.includes('application/vnd.apple.mpegurl') || contentType.includes('text/plain'))) {
                        this.showNotification(`✅ M3U source accessible! Size: ${size}`, 'success');
                    } else {
                        this.showNotification(`⚠️ Source accessible but content type uncertain (${contentType || 'unknown'})`, 'warning');
                    }
                }
            } else {
                this.showNotification(`❌ M3U source not accessible: ${response.status} ${response.statusText}`, 'error');
            }
        } catch (error) {
            console.error('Validation error:', error);
            this.showNotification('❌ M3U validation failed: Network error or CORS restriction', 'error');
        } finally {
            validateBtn.innerHTML = originalContent;
            validateBtn.disabled = false;
        }
    }
    
    getImportOptions() {
        return {
            updateExisting: document.getElementById('updateExisting').checked,
            preserveGroups: document.getElementById('preserveGroups').checked,
            epgMapping: document.querySelector('input[name="epgMapping"]:checked').value,
            validateUrls: document.getElementById('validateUrls').checked,
            skipDuplicates: document.getElementById('skipDuplicates').checked,
            filterAdult: document.getElementById('filterAdult').checked,
            onlyHD: document.getElementById('onlyHD').checked,
            testStreams: document.getElementById('testStreams').checked,
            epgUrl: document.getElementById('epgUrl').value.trim()
        };
    }
    
    switchPlaylistSubTab(subTab) {
        // Update sub-tab buttons
        document.getElementById('sourcesSubTab').classList.toggle('active', subTab === 'sources');
        document.getElementById('importedSubTab').classList.toggle('active', subTab === 'imported');
        
        // Update sub-panels
        document.getElementById('sources-subpanel').style.display = subTab === 'sources' ? 'block' : 'none';
        document.getElementById('imported-subpanel').style.display = subTab === 'imported' ? 'block' : 'none';
    }
    
    async loadSources() {
        try {
            const response = await fetch('/api/channels/playlists', {
                headers: {
                    'Authorization': `Bearer ${localStorage.getItem('token')}`
                }
            });
            
            if (response.ok) {
                const sources = await response.json();
                
                const container = document.getElementById('sourcesList');
                container.innerHTML = '';
                
                sources.forEach(source => {
                    const item = this.createSourceItem(source);
                    container.appendChild(item);
                });
            } else {
                console.error('Failed to load sources:', response.status);
                document.getElementById('sourcesList').innerHTML = '<p class="text-muted">No sources available or failed to load.</p>';
            }
        } catch (error) {
            console.error('Error loading sources:', error);
            document.getElementById('sourcesList').innerHTML = '<p class="text-muted">Error loading sources.</p>';
        }
    }
    
    createSourceItem(source) {
        const item = document.createElement('div');
        item.className = 'playlist-item';
        item.innerHTML = `
            <div class="playlist-info">
                <div class="playlist-name">${source.name}</div>
                <div class="playlist-meta">
                    <span><i class="bi bi-link"></i> ${this.truncateUrl(source.url)}</span>
                    <span><i class="bi bi-calendar"></i> ${this.formatDate(source.last_updated)}</span>
                    ${source.epg_url ? `<span><i class="bi bi-broadcast"></i> EPG linked</span>` : ''}
                    <span><i class="bi bi-collection"></i> ${source.channel_count || 0} channels</span>
                    <span class="badge ${source.status === 'active' ? 'bg-success' : source.status === 'importing' ? 'bg-warning' : 'bg-secondary'}">${source.status || 'unknown'}</span>
                </div>
            </div>
            <div class="playlist-actions">
                <button class="action-btn" title="Configure Source" onclick="importManager.configureSource(${source.id})">
                    <i class="bi bi-gear"></i>
                </button>
                <button class="action-btn" title="Import Now" onclick="importManager.importSource(${source.id})">
                    <i class="bi bi-download"></i>
                </button>
                <button class="action-btn" title="Refresh Import" onclick="importManager.refreshPlaylist(${source.id})">
                    <i class="bi bi-arrow-clockwise"></i>
                </button>
                <button class="action-btn danger" title="Delete" onclick="importManager.deleteSource(${source.id})">
                    <i class="bi bi-trash"></i>
                </button>
            </div>
        `;
        return item;
    }
    
    async loadSource(sourceId) {
        try {
            // Get playlist details from existing API
            const response = await fetch(`/api/channels/playlists`, {
                headers: {
                    'Authorization': `Bearer ${localStorage.getItem('token')}`
                }
            });
            
            if (response.ok) {
                const playlists = await response.json();
                const source = playlists.find(p => p.id === sourceId);
                
                if (source) {
                    // Load source data into form
                    document.getElementById('sourceName').value = source.name;
                    document.getElementById('m3uUrl').value = source.url;
                    document.getElementById('epgUrl').value = source.epg_url || '';
                    
                    // Switch to M3U tab
                    this.switchTab('m3u');
                    this.showNotification(`Loaded source: ${source.name}`, 'info');
                } else {
                    throw new Error('Source not found');
                }
            } else {
                throw new Error('Failed to fetch sources');
            }
            
        } catch (error) {
            this.showNotification('Failed to load source: ' + error.message, 'error');
        }
    }
    
    async importSource(sourceId) {
        const source = await this.getSource(sourceId);
        if (source) {
            await this.loadSource(sourceId);
            setTimeout(() => this.startImport(), 500); // Brief delay to ensure form is loaded
        }
    }
    
    async getSource(sourceId) {
        try {
            const response = await fetch('/api/channels/playlists', {
                headers: {
                    'Authorization': `Bearer ${localStorage.getItem('token')}`
                }
            });
            
            if (response.ok) {
                const playlists = await response.json();
                return playlists.find(p => p.id === sourceId);
            } else {
                throw new Error('Failed to fetch sources');
            }
        } catch (error) {
            this.showNotification('Failed to get source: ' + error.message, 'error');
            return null;
        }
    }
    
    loadPlaylists() {
        const container = document.getElementById('playlistList');
        container.innerHTML = '';
        
        this.playlists.forEach(playlist => {
            const item = this.createPlaylistItem(playlist);
            container.appendChild(item);
        });
    }
    
    createPlaylistItem(playlist) {
        const item = document.createElement('div');
        item.className = 'playlist-item';
        item.innerHTML = `
            <div class="playlist-info">
                <div class="playlist-name">${playlist.name}</div>
                <div class="playlist-meta">
                    <span><i class="bi bi-link"></i> ${this.truncateUrl(playlist.url)}</span>
                    <span><i class="bi bi-calendar"></i> ${this.formatDate(playlist.last_updated)}</span>
                    <span><i class="bi bi-collection"></i> ${playlist.channel_count || 0} channels</span>
                    ${playlist.epg_url ? `<span><i class="bi bi-broadcast"></i> EPG linked</span>` : ''}
                </div>
            </div>
            <div class="playlist-actions">
                <button class="action-btn" title="Edit" onclick="importManager.editPlaylist(${playlist.id})">
                    <i class="bi bi-pencil"></i>
                </button>
                <button class="action-btn" title="Refresh" onclick="importManager.refreshPlaylist(${playlist.id})">
                    <i class="bi bi-arrow-clockwise"></i>
                </button>
                <button class="action-btn danger" title="Delete" onclick="importManager.deletePlaylist(${playlist.id})">
                    <i class="bi bi-trash"></i>
                </button>
            </div>
        `;
        return item;
    }
    
    truncateUrl(url) {
        return url.length > 50 ? url.substring(0, 50) + '...' : url;
    }
    
    formatDate(dateString) {
        if (!dateString) return 'Never';
        return new Date(dateString).toLocaleDateString();
    }
    
    loadRecentActivity() {
        const container = document.getElementById('recentImports');
        // This would be loaded from actual API
        const recentActivity = [
            { status: 'success', message: 'IPTV Playlist imported', time: '2 hours ago' },
            { status: 'warning', message: '5 channels failed validation', time: '1 day ago' },
            { status: 'success', message: 'EPG data updated', time: '2 days ago' }
        ];
        
        container.innerHTML = '';
        recentActivity.forEach(activity => {
            const item = document.createElement('div');
            item.className = 'import-log-item';
            item.innerHTML = `
                <div class="log-status ${activity.status}"></div>
                <div class="log-details">${activity.message}</div>
                <div class="log-time">${activity.time}</div>
            `;
            container.appendChild(item);
        });
    }
    
    showNotification(message, type = 'info') {
        const alertDiv = document.createElement('div');
        alertDiv.className = `alert alert-${type} alert-dismissible fade show position-fixed top-0 end-0 m-3`;
        alertDiv.style.zIndex = '9999';
        alertDiv.innerHTML = `
            ${message}
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        `;
        
        document.body.appendChild(alertDiv);
        
        setTimeout(() => {
            alertDiv.remove();
        }, 5000);
    }
    
    async testEpgSource() {
        const epgUrl = document.getElementById('epgUrl').value.trim();
        if (!epgUrl) {
            this.showNotification('Please enter an EPG URL to test', 'warning');
            return;
        }
        
        const testBtn = document.getElementById('testEpgBtn');
        const originalContent = testBtn.innerHTML;
        testBtn.innerHTML = '<i class="bi bi-arrow-clockwise spinning"></i> Testing...';
        testBtn.disabled = true;
        
        try {
            // Test EPG URL accessibility
            const response = await fetch(epgUrl, { 
                method: 'HEAD',
                mode: 'cors'
            });
            
            if (response.ok) {
                const contentType = response.headers.get('content-type');
                const contentLength = response.headers.get('content-length');
                const size = contentLength ? Math.round(parseInt(contentLength) / 1024) + ' KB' : 'Unknown size';
                
                // Try to fetch a small portion to validate XML content
                try {
                    const partialResponse = await fetch(epgUrl, {
                        headers: { 'Range': 'bytes=0-2047' }
                    });
                    const sample = await partialResponse.text();
                    
                    if (sample.includes('<?xml') && sample.includes('<tv')) {
                        this.showNotification(`✅ Valid XMLTV EPG source! Size: ${size}`, 'success');
                    } else if (sample.includes('<?xml')) {
                        this.showNotification(`⚠️ XML file but may not be XMLTV format. Size: ${size}`, 'warning');
                    } else {
                        this.showNotification(`⚠️ File accessible but doesn't appear to be XML. Size: ${size}`, 'warning');
                    }
                } catch (rangeError) {
                    // Fallback to content-type check
                    if (contentType && (contentType.includes('xml') || contentType.includes('text'))) {
                        this.showNotification(`✅ EPG source accessible! Size: ${size}, Type: ${contentType}`, 'success');
                    } else {
                        this.showNotification(`⚠️ EPG source accessible but content type uncertain (${contentType || 'unknown'})`, 'warning');
                    }
                }
            } else {
                this.showNotification(`❌ EPG source not accessible: ${response.status} ${response.statusText}`, 'error');
            }
        } catch (error) {
            console.error('EPG test error:', error);
            this.showNotification('❌ EPG test failed: Network error or CORS restriction', 'error');
        } finally {
            testBtn.innerHTML = originalContent;
            testBtn.disabled = false;
        }
    }
    
    // Additional source management methods
    async editSource(sourceId) {
        await this.loadSource(sourceId);
        this.showNotification('Source loaded for editing', 'info');
    }
    
    async deleteSource(sourceId) {
        if (!confirm('Are you sure you want to delete this source? This will remove all associated channels.')) return;
        
        try {
            const response = await fetch(`/api/channels/playlists/${sourceId}`, {
                method: 'DELETE',
                headers: {
                    'Authorization': `Bearer ${localStorage.getItem('token')}`
                }
            });
            
            if (response.ok) {
                this.showNotification('Source deleted successfully', 'success');
                await this.loadSources();
                await this.loadData(); // Refresh stats
            } else {
                const error = await response.json();
                throw new Error(error.detail || 'Failed to delete source');
            }
        } catch (error) {
            this.showNotification('Failed to delete source: ' + error.message, 'error');
        }
    }
    
    // Real implementation methods
    async loadEpgSources() { 
        try {
            const response = await fetch('/api/epg/sources', {
                headers: {
                    'Authorization': `Bearer ${localStorage.getItem('token')}`
                }
            });
            
            if (response.ok) {
                const sources = await response.json();
                console.log('Loaded EPG sources:', sources);
                // Update UI with EPG sources
            }
        } catch (error) {
            console.error('Failed to load EPG sources:', error);
        }
    }
    
    exportData() { 
        const selectedFormat = document.querySelector('.export-format.selected');
        if (selectedFormat) {
            const format = selectedFormat.dataset.format;
            let endpoint = '';
            
            switch(format) {
                case 'm3u':
                    endpoint = '/api/channels/export/m3u';
                    break;
                case 'json':
                    endpoint = '/api/channels/export/json';
                    break;
                case 'xmltv':
                    endpoint = '/api/epg/export/xmltv';
                    break;
                default:
                    this.showNotification('Unknown export format', 'error');
                    return;
            }
            
            window.open(endpoint, '_blank');
            this.showNotification(`Exporting ${format.toUpperCase()} format...`, 'info');
        } else {
            this.showNotification('Please select an export format', 'warning');
        }
    }
    
    editPlaylist(id) { 
        // Load playlist into form for editing
        this.loadSource(id);
    }
    
    async refreshPlaylist(id) { 
        try {
            const response = await fetch(`/api/channels/playlists/${id}/refresh`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${localStorage.getItem('token')}`
                }
            });
            
            if (response.ok) {
                const result = await response.json();
                this.showNotification(`Playlist refresh started: ${result.import_id}`, 'success');
                setTimeout(() => this.loadSources(), 2000); // Refresh list after delay
            } else {
                throw new Error('Failed to refresh playlist');
            }
        } catch (error) {
            this.showNotification('Failed to refresh playlist: ' + error.message, 'error');
        }
    }
    
    async deletePlaylist(id) { 
        if (confirm('Delete this playlist and all its channels?')) {
            await this.deleteSource(id); // Use the same delete method
        }
    }
    
    async refreshAllPlaylists() { 
        try {
            const response = await fetch('/api/channels/playlists', {
                headers: {
                    'Authorization': `Bearer ${localStorage.getItem('token')}`
                }
            });
            
            if (response.ok) {
                const playlists = await response.json();
                let refreshed = 0;
                
                for (const playlist of playlists) {
                    try {
                        await fetch(`/api/channels/playlists/${playlist.id}/refresh`, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${localStorage.getItem('token')}`
                            }
                        });
                        refreshed++;
                    } catch (error) {
                        console.error(`Failed to refresh playlist ${playlist.id}:`, error);
                    }
                }
                
                this.showNotification(`Started refresh for ${refreshed} playlists`, 'success');
            }
        } catch (error) {
            this.showNotification('Failed to refresh playlists: ' + error.message, 'error');
        }
    }
    
    validateAllStreams() { 
        this.showNotification('Stream validation is not implemented yet', 'info');
    }
    
    cleanupInactive() { 
        if (confirm('Remove inactive channels and groups? This cannot be undone.')) {
            this.showNotification('Cleanup feature is not implemented yet', 'info');
        }
    }
    
    async backupConfiguration() { 
        try {
            this.showNotification('Creating backup...', 'info');
            
            // Get all data for backup
            const [channelsRes, playlistsRes, epgRes] = await Promise.all([
                fetch('/api/channels/', {
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('token')}` }
                }),
                fetch('/api/channels/playlists', {
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('token')}` }
                }),
                fetch('/api/epg/sources', {
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('token')}` }
                })
            ]);
            
            const backup = {
                timestamp: new Date().toISOString(),
                channels: channelsRes.ok ? await channelsRes.json() : [],
                playlists: playlistsRes.ok ? await playlistsRes.json() : [],
                epgSources: epgRes.ok ? await epgRes.json() : []
            };
            
            const blob = new Blob([JSON.stringify(backup, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `iptv-backup-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            this.showNotification('Backup downloaded successfully', 'success');
        } catch (error) {
            this.showNotification('Failed to create backup: ' + error.message, 'error');
        }
    }
}

// Initialize when page loads
document.addEventListener('DOMContentLoaded', () => {
    window.importManager = new ImportManager();
});
</script>
{% endblock %}